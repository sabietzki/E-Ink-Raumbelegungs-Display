#!/usr/bin/env python3
# Erzeugt icons_data.h aus firmware/data/*.bmp (nur 1-bit BMP, max 160×160).
# Keine Umwandlung – die BMPs müssen in Photoshop o. Ä. als 150×150, 1-bit gespeichert werden.
# Aufruf: python3 embed_icons.py [--force]

import os
import struct
import sys

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(SCRIPT_DIR, "data")
OUTPUT_FILE = os.path.join(SCRIPT_DIR, "icons_data.h")
OUTPUT_GFX_FILE = os.path.join(SCRIPT_DIR, "icons_gfx.h")
ICONS = ("no_wifi", "low_battery", "no_connection")
BYTES_PER_LINE = 24
MAX_ICON_W = 160
MAX_ICON_H = 160


def bmp_header_size(data):
    if len(data) < 54 or data[:2] != b"BM":
        return None, None, None
    w = struct.unpack("<i", data[18:22])[0]
    h = struct.unpack("<i", data[22:26])[0]
    bpp = struct.unpack("<H", data[28:30])[0]
    return abs(w), abs(h), bpp


def get_icon_bmp_bytes(name):
    bmp_path = os.path.join(DATA_DIR, name + ".bmp")
    if not os.path.isfile(bmp_path):
        return None
    with open(bmp_path, "rb") as f:
        data = f.read()
    if data[:2] != b"BM" or len(data) < 54:
        return None
    w, h, bpp = bmp_header_size(data)
    if w is None:
        return None
    if w > MAX_ICON_W or h > MAX_ICON_H:
        print(f"Hinweis: {name}.bmp ist {w}×{h} – max 160×160. Siehe WordPress-Hilfe „Icons selbst erstellen (Photoshop)“.")
        return None
    if bpp != 1:
        print(f"Hinweis: {name}.bmp ist {bpp}-bit – 1-bit nötig. In Photoshop: Modus → Bitmap, dann als BMP speichern.")
        return None
    return data


def bmp_to_gfx(data):
    """Konvertiert 1-bit BMP (bottom-up) in Adafruit-GFX-Format (top-down, (w+7)/8 Bytes/Zeile)."""
    if len(data) < 54:
        return None, 0, 0
    offset = struct.unpack("<I", data[10:14])[0]
    w = struct.unpack("<i", data[18:22])[0]
    h = struct.unpack("<i", data[22:26])[0]
    w, h = abs(w), abs(h)
    row_bytes_bmp = ((w + 31) // 32) * 4
    row_bytes_gfx = (w + 7) // 8
    total_gfx = row_bytes_gfx * h
    if offset + row_bytes_bmp * h > len(data):
        return None, 0, 0
    out = bytearray(total_gfx)
    for gfx_row in range(h):
        bmp_row = h - 1 - gfx_row  # BMP: Zeile 0 = unten
        src = offset + bmp_row * row_bytes_bmp
        for i in range(row_bytes_gfx):
            if src + i < len(data):
                out[gfx_row * row_bytes_gfx + i] = data[src + i]
    return bytes(out), w, h


def need_rebuild():
    if not os.path.isfile(OUTPUT_FILE):
        return True
    out_mtime = os.path.getmtime(OUTPUT_FILE)
    for name in ICONS:
        p = os.path.join(DATA_DIR, name + ".bmp")
        if os.path.isfile(p) and os.path.getmtime(p) > out_mtime:
            return True
    return False


def build_content():
    parts = [
        "// Auto-generated by embed_icons.py – Do not edit.",
        "// Fehler-Icons als 1-bit BMP aus data/*.bmp (150×150, in Photoshop erzeugt).",
        "",
        "#ifndef ICONS_DATA_H",
        "#define ICONS_DATA_H",
        "",
    ]
    for name in ICONS:
        var_name = "ICON_" + name.upper().replace("-", "_") + "_BMP"
        len_name = var_name + "_LEN"
        data = get_icon_bmp_bytes(name)
        if not data:
            parts.append(f"const unsigned char {var_name}[] PROGMEM = {{ 0 }};")
            parts.append(f"const unsigned int {len_name} = 0;")
        else:
            parts.append(f"const unsigned char {var_name}[] PROGMEM = {{")
            for i in range(0, len(data), BYTES_PER_LINE):
                chunk = data[i : i + BYTES_PER_LINE]
                parts.append("  " + ", ".join(f"0x{b:02x}" for b in chunk) + ",")
            parts.append("};")
            parts.append(f"const unsigned int {len_name} = {len(data)};")
        parts.append("")
    parts.append("#endif")
    return "\n".join(parts) + "\n"


def build_gfx_content():
    parts = [
        "// Auto-generated by embed_icons.py – Do not edit.",
        "// Fehler-Icons im Adafruit-GFX-Format (1-bit, top-down) für drawBitmap().",
        "",
        "#ifndef ICONS_GFX_H",
        "#define ICONS_GFX_H",
        "",
    ]
    for name in ICONS:
        data = get_icon_bmp_bytes(name)
        if not data:
            var = "ICON_" + name.upper().replace("-", "_") + "_GFX"
            parts.append(f"#define {var}_LEN 0")
            parts.append(f"#define {var}_W 0")
            parts.append(f"#define {var}_H 0")
        else:
            gfx, w, h = bmp_to_gfx(data)
            var = "ICON_" + name.upper().replace("-", "_") + "_GFX"
            parts.append(f"#define {var}_W {w}")
            parts.append(f"#define {var}_H {h}")
            parts.append(f"#define {var}_LEN {len(gfx)}")
            parts.append(f"const unsigned char {var}[] PROGMEM = {{")
            for i in range(0, len(gfx), BYTES_PER_LINE):
                chunk = gfx[i : i + BYTES_PER_LINE]
                parts.append("  " + ", ".join(f"0x{b:02x}" for b in chunk) + ",")
            parts.append("};")
        parts.append("")
    parts.append("#endif")
    return "\n".join(parts) + "\n"


def need_rebuild_gfx():
    if not os.path.isfile(OUTPUT_GFX_FILE):
        return True
    out_mtime = os.path.getmtime(OUTPUT_GFX_FILE)
    for name in ICONS:
        p = os.path.join(DATA_DIR, name + ".bmp")
        if os.path.isfile(p) and os.path.getmtime(p) > out_mtime:
            return True
    return False


def main():
    force = "--force" in sys.argv
    if not force and not need_rebuild() and not need_rebuild_gfx():
        return
    content = build_content()
    with open(OUTPUT_FILE, "w") as f:
        f.write(content)
    gfx_content = build_gfx_content()
    with open(OUTPUT_GFX_FILE, "w") as f:
        f.write(gfx_content)
    print("icons_data.h und icons_gfx.h erzeugt (BMP + GFX für drawBitmap).")


if __name__ == "__main__":
    main()
